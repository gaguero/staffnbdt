# Internationalization (i18n) Guide

## Overview

Hotel Operations Hub is designed to support multiple languages and locales, enabling hotels to serve international staff and guests. The system currently supports English and Spanish, with architecture prepared for AI-powered translation expansion.

## Supported Languages

### Currently Available
- **English (en)** - Primary language, default fallback
- **Spanish (es)** - Full translation support

### Planned Languages
- **French (fr)** - European and Canadian markets
- **German (de)** - German-speaking regions
- **Portuguese (pt)** - Brazil and Portugal
- **Italian (it)** - Italian market
- **Chinese (zh)** - Asian markets
- **Japanese (ja)** - Japanese market

## Architecture Overview

### Language Hierarchy

```
Platform Languages (Default translations)
├── Organization Languages (Chain-specific overrides)
│   └── Property Languages (Hotel-specific overrides)
└── User Language Preferences (Personal settings)
```

### Translation Resolution Order

1. **User's language preference**
2. **Property-specific translation override**
3. **Organization-specific translation override**
4. **Platform default translation**
5. **AI-generated translation** (if enabled)
6. **Fallback to English**

## Database Schema

### Language Management

```sql
-- Supported languages
CREATE TABLE languages (
    code TEXT PRIMARY KEY, -- ISO 639-1 code (e.g., 'en', 'es')
    name TEXT NOT NULL, -- English name (e.g., 'Spanish')
    native_name TEXT NOT NULL, -- Native name (e.g., 'Español')
    direction TEXT NOT NULL DEFAULT 'ltr' CHECK (direction IN ('ltr', 'rtl')),
    enabled BOOLEAN NOT NULL DEFAULT true,
    
    -- Locale information
    locale_code TEXT, -- Full locale (e.g., 'es-ES', 'es-MX')
    country_code TEXT, -- ISO 3166-1 alpha-2 (e.g., 'ES', 'MX')
    
    -- Formatting preferences
    date_format TEXT DEFAULT 'MM/DD/YYYY',
    time_format TEXT DEFAULT '12h', -- '12h' or '24h'
    currency_format TEXT DEFAULT 'symbol', -- 'symbol', 'code', 'name'
    number_format JSONB DEFAULT '{}', -- Decimal separator, thousands separator
    
    -- Metadata
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Translation keys and content
CREATE TABLE translations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Translation identification
    key TEXT NOT NULL, -- 'dashboard.welcome', 'common.save'
    namespace TEXT NOT NULL, -- 'common', 'hr', 'front_desk', etc.
    language_code TEXT NOT NULL REFERENCES languages(code),
    
    -- Translation content
    value TEXT NOT NULL, -- The actual translation
    plurals JSONB, -- Plural forms for complex languages
    variables JSONB, -- Variables used in translation (for validation)
    
    -- Context and metadata
    context TEXT, -- Additional context for translators
    description TEXT, -- Description of when/how it's used
    max_length INTEGER, -- Maximum length constraint
    
    -- Quality and status
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'verified', 'ai_generated', 'deprecated')),
    quality_score DECIMAL(3,2), -- 0.00 to 1.00 quality rating
    
    -- Tracking
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by UUID REFERENCES users(id),
    verified_by UUID REFERENCES users(id),
    verified_at TIMESTAMPTZ,
    
    -- Constraints
    UNIQUE (key, namespace, language_code)
);

-- Organization-level translation overrides
CREATE TABLE organization_translations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE,
    translation_id UUID NOT NULL REFERENCES translations(id) ON DELETE CASCADE,
    
    -- Override content
    custom_value TEXT NOT NULL,
    custom_plurals JSONB,
    
    -- Tracking
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by UUID NOT NULL REFERENCES users(id),
    
    UNIQUE (organization_id, translation_id)
);

-- Property-level translation overrides
CREATE TABLE property_translations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    property_id UUID NOT NULL REFERENCES properties(id) ON DELETE CASCADE,
    translation_id UUID NOT NULL REFERENCES translations(id) ON DELETE CASCADE,
    
    -- Override content
    custom_value TEXT NOT NULL,
    custom_plurals JSONB,
    
    -- Tracking
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by UUID NOT NULL REFERENCES users(id),
    
    UNIQUE (property_id, translation_id)
);

-- User language preferences
CREATE TABLE user_language_preferences (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    
    -- Language settings
    primary_language TEXT NOT NULL REFERENCES languages(code) DEFAULT 'en',
    fallback_language TEXT REFERENCES languages(code) DEFAULT 'en',
    
    -- Regional settings
    timezone TEXT NOT NULL DEFAULT 'UTC',
    date_format TEXT,
    time_format TEXT,
    currency_code TEXT,
    number_format JSONB,
    
    -- Auto-translation preferences
    enable_ai_translation BOOLEAN DEFAULT true,
    auto_detect_language BOOLEAN DEFAULT false,
    
    -- Metadata
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Translation memory for AI optimization
CREATE TABLE translation_memory (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    
    -- Source and target
    source_text TEXT NOT NULL,
    source_language TEXT NOT NULL REFERENCES languages(code),
    target_text TEXT NOT NULL,
    target_language TEXT NOT NULL REFERENCES languages(code),
    
    -- Context
    domain TEXT, -- 'hospitality', 'finance', 'hr'
    context_tags TEXT[], -- ['formal', 'customer-facing', 'technical']
    
    -- Quality metrics
    confidence_score DECIMAL(3,2),
    human_verified BOOLEAN DEFAULT false,
    usage_count INTEGER DEFAULT 0,
    
    -- Metadata
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_used_at TIMESTAMPTZ,
    
    UNIQUE (source_text, source_language, target_language, domain)
);
```

## Backend Implementation

### Translation Service

```typescript
@Injectable()
export class TranslationService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly aiTranslationService: AITranslationService,
    private readonly cacheService: CacheService,
  ) {}

  async getTranslation(
    key: string,
    language: string,
    options: {
      namespace?: string;
      organizationId?: string;
      propertyId?: string;
      variables?: Record<string, any>;
      fallbackLanguage?: string;
    } = {}
  ): Promise<string> {
    const {
      namespace = 'common',
      organizationId,
      propertyId,
      variables = {},
      fallbackLanguage = 'en',
    } = options;

    // Try cache first
    const cacheKey = `translation:${key}:${namespace}:${language}:${organizationId}:${propertyId}`;
    const cached = await this.cacheService.get(cacheKey);
    if (cached) {
      return this.interpolateVariables(cached, variables);
    }

    let translation: string | null = null;

    // 1. Try property-specific override
    if (propertyId) {
      translation = await this.getPropertyTranslation(key, namespace, language, propertyId);
    }

    // 2. Try organization-specific override
    if (!translation && organizationId) {
      translation = await this.getOrganizationTranslation(key, namespace, language, organizationId);
    }

    // 3. Try platform default
    if (!translation) {
      translation = await this.getPlatformTranslation(key, namespace, language);
    }

    // 4. Try AI translation if enabled
    if (!translation && language !== fallbackLanguage) {
      translation = await this.getAITranslation(key, namespace, language, fallbackLanguage, {
        organizationId,
        propertyId,
      });
    }

    // 5. Fallback to fallback language
    if (!translation && language !== fallbackLanguage) {
      translation = await this.getPlatformTranslation(key, namespace, fallbackLanguage);
    }

    // 6. Final fallback to key itself
    if (!translation) {
      translation = key;
      console.warn(`Translation not found: ${key} (${namespace}) for language ${language}`);
    }

    // Cache the result
    await this.cacheService.set(cacheKey, translation, 3600); // 1 hour

    return this.interpolateVariables(translation, variables);
  }

  async createTranslation(
    data: CreateTranslationDto,
    createdBy: string
  ): Promise<Translation> {
    // Validate variables in translation
    this.validateTranslationVariables(data.value, data.variables);

    const translation = await this.prisma.translation.create({
      data: {
        ...data,
        createdBy,
      },
    });

    // Invalidate cache
    await this.invalidateTranslationCache(data.key, data.namespace, data.languageCode);

    return translation;
  }

  async updateTranslation(
    id: string,
    updates: UpdateTranslationDto,
    updatedBy: string
  ): Promise<Translation> {
    const existing = await this.prisma.translation.findUnique({
      where: { id },
    });

    if (!existing) {
      throw new NotFoundException('Translation not found');
    }

    if (updates.value) {
      this.validateTranslationVariables(updates.value, updates.variables || existing.variables);
    }

    const translation = await this.prisma.translation.update({
      where: { id },
      data: {
        ...updates,
        updatedAt: new Date(),
      },
    });

    // Invalidate cache
    await this.invalidateTranslationCache(existing.key, existing.namespace, existing.languageCode);

    return translation;
  }

  async bulkImportTranslations(
    file: Express.Multer.File,
    language: string,
    namespace: string,
    organizationId?: string,
    propertyId?: string
  ): Promise<BulkImportResult> {
    const content = file.buffer.toString('utf-8');
    let translations: Record<string, string>;

    try {
      // Support JSON, CSV, and XLIFF formats
      if (file.mimetype === 'application/json') {
        translations = JSON.parse(content);
      } else if (file.mimetype === 'text/csv') {
        translations = this.parseCSVTranslations(content);
      } else if (file.mimetype === 'application/xliff+xml') {
        translations = this.parseXLIFFTranslations(content);
      } else {
        throw new BadRequestException('Unsupported file format');
      }
    } catch (error) {
      throw new BadRequestException('Invalid file format');
    }

    const results = {
      total: Object.keys(translations).length,
      success: 0,
      failed: 0,
      errors: [] as string[],
    };

    for (const [key, value] of Object.entries(translations)) {
      try {
        if (organizationId) {
          await this.createOrganizationTranslation(organizationId, key, namespace, language, value);
        } else if (propertyId) {
          await this.createPropertyTranslation(propertyId, key, namespace, language, value);
        } else {
          await this.createTranslation({
            key,
            namespace,
            languageCode: language,
            value,
          }, 'system');
        }
        results.success++;
      } catch (error) {
        results.failed++;
        results.errors.push(`${key}: ${error.message}`);
      }
    }

    return results;
  }

  private async getPropertyTranslation(
    key: string,
    namespace: string,
    language: string,
    propertyId: string
  ): Promise<string | null> {
    const result = await this.prisma.propertyTranslation.findFirst({
      where: {
        propertyId,
        translation: {
          key,
          namespace,
          languageCode: language,
          status: { not: 'deprecated' },
        },
      },
      select: {
        customValue: true,
      },
    });

    return result?.customValue || null;
  }

  private async getOrganizationTranslation(
    key: string,
    namespace: string,
    language: string,
    organizationId: string
  ): Promise<string | null> {
    const result = await this.prisma.organizationTranslation.findFirst({
      where: {
        organizationId,
        translation: {
          key,
          namespace,
          languageCode: language,
          status: { not: 'deprecated' },
        },
      },
      select: {
        customValue: true,
      },
    });

    return result?.customValue || null;
  }

  private async getPlatformTranslation(
    key: string,
    namespace: string,
    language: string
  ): Promise<string | null> {
    const translation = await this.prisma.translation.findUnique({
      where: {
        key_namespace_languageCode: {
          key,
          namespace,
          languageCode: language,
        },
      },
      select: {
        value: true,
      },
    });

    return translation?.value || null;
  }

  private async getAITranslation(
    key: string,
    namespace: string,
    targetLanguage: string,
    sourceLanguage: string,
    context: { organizationId?: string; propertyId?: string }
  ): Promise<string | null> {
    // Get source translation
    const sourceTranslation = await this.getPlatformTranslation(key, namespace, sourceLanguage);
    if (!sourceTranslation) {
      return null;
    }

    try {
      // Check translation memory first
      const memoryResult = await this.prisma.translationMemory.findFirst({
        where: {
          sourceText: sourceTranslation,
          sourceLanguage,
          targetLanguage,
          domain: namespace,
        },
        orderBy: { confidence_score: 'desc' },
      });

      if (memoryResult && memoryResult.confidence_score > 0.8) {
        return memoryResult.target_text;
      }

      // Use AI translation service
      const aiTranslation = await this.aiTranslationService.translate({
        text: sourceTranslation,
        from: sourceLanguage,
        to: targetLanguage,
        context: namespace,
        domain: 'hospitality',
      });

      // Save to translation memory
      await this.prisma.translationMemory.upsert({
        where: {
          sourceText_sourceLanguage_targetLanguage_domain: {
            sourceText: sourceTranslation,
            sourceLanguage,
            targetLanguage,
            domain: namespace,
          },
        },
        update: {
          targetText: aiTranslation.text,
          confidenceScore: aiTranslation.confidence,
          usageCount: { increment: 1 },
          lastUsedAt: new Date(),
        },
        create: {
          sourceText: sourceTranslation,
          sourceLanguage,
          targetText: aiTranslation.text,
          targetLanguage,
          domain: namespace,
          confidenceScore: aiTranslation.confidence,
          usageCount: 1,
          lastUsedAt: new Date(),
        },
      });

      // Create platform translation for future use
      await this.createTranslation({
        key,
        namespace,
        languageCode: targetLanguage,
        value: aiTranslation.text,
        status: 'ai_generated',
        qualityScore: aiTranslation.confidence,
      }, 'ai-system');

      return aiTranslation.text;
    } catch (error) {
      console.error('AI translation failed:', error);
      return null;
    }
  }

  private interpolateVariables(text: string, variables: Record<string, any>): string {
    return text.replace(/\{\{(\w+)\}\}/g, (match, key) => {
      return variables[key] !== undefined ? String(variables[key]) : match;
    });
  }

  private validateTranslationVariables(text: string, expectedVariables?: string[]): void {
    const variablesInText = [...text.matchAll(/\{\{(\w+)\}\}/g)].map(match => match[1]);
    
    if (expectedVariables) {
      const missing = expectedVariables.filter(v => !variablesInText.includes(v));
      const extra = variablesInText.filter(v => !expectedVariables.includes(v));
      
      if (missing.length > 0 || extra.length > 0) {
        throw new BadRequestException(
          `Variable mismatch. Missing: ${missing.join(', ')}, Extra: ${extra.join(', ')}`
        );
      }
    }
  }
}
```

### AI Translation Service

```typescript
@Injectable()
export class AITranslationService {
  constructor(private readonly openai: OpenAI) {}

  async translate(options: {
    text: string;
    from: string;
    to: string;
    context?: string;
    domain?: string;
  }): Promise<{ text: string; confidence: number }> {
    const { text, from, to, context = '', domain = 'general' } = options;

    const prompt = this.buildTranslationPrompt(text, from, to, context, domain);

    try {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4',
        messages: [
          {
            role: 'system',
            content: 'You are a professional translator specializing in hospitality and business applications. Provide accurate, context-appropriate translations.',
          },
          {
            role: 'user',
            content: prompt,
          },
        ],
        temperature: 0.1, // Low temperature for consistency
        max_tokens: 1000,
      });

      const result = response.choices[0]?.message?.content;
      if (!result) {
        throw new Error('No translation received from AI');
      }

      // Parse response (expecting JSON format)
      const parsed = JSON.parse(result);
      
      return {
        text: parsed.translation,
        confidence: parsed.confidence || 0.8,
      };
    } catch (error) {
      console.error('AI translation error:', error);
      throw new Error('Translation service unavailable');
    }
  }

  private buildTranslationPrompt(
    text: string,
    from: string,
    to: string,
    context: string,
    domain: string
  ): string {
    return `
Translate the following text from ${from} to ${to}.

Domain: ${domain}
Context: ${context}

Text to translate: "${text}"

Important guidelines:
1. Maintain any variables in the format {{variableName}}
2. Preserve formatting and punctuation appropriately
3. Use appropriate tone for hospitality/business context
4. Return response as JSON: {"translation": "...", "confidence": 0.95}

Translation:`;
  }

  async translateBatch(
    texts: string[],
    from: string,
    to: string,
    context?: string
  ): Promise<Array<{ text: string; confidence: number }>> {
    // Implement batch translation for efficiency
    const batchSize = 10;
    const results = [];

    for (let i = 0; i < texts.length; i += batchSize) {
      const batch = texts.slice(i, i + batchSize);
      const batchPromise = batch.map(text => 
        this.translate({ text, from, to, context })
      );
      const batchResults = await Promise.all(batchPromise);
      results.push(...batchResults);
    }

    return results;
  }
}
```

## Frontend Implementation

### React i18next Setup

```typescript
// i18n configuration
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import Backend from 'i18next-http-backend';
import LanguageDetector from 'i18next-browser-languagedetector';

i18n
  .use(Backend) // Load translations from server
  .use(LanguageDetector) // Detect user language
  .use(initReactI18next) // Pass to react-i18next
  .init({
    fallbackLng: 'en',
    debug: process.env.NODE_ENV === 'development',
    
    interpolation: {
      escapeValue: false, // React already escapes
    },
    
    backend: {
      loadPath: '/api/translations/{{lng}}/{{ns}}',
      addPath: '/api/translations/{{lng}}/{{ns}}',
    },
    
    detection: {
      order: ['localStorage', 'navigator', 'htmlTag'],
      caches: ['localStorage'],
    },
    
    // Namespace loading
    ns: ['common', 'hr', 'front_desk', 'housekeeping', 'maintenance'],
    defaultNS: 'common',
    
    // React i18next options
    react: {
      useSuspense: false,
    },
  });

export default i18n;
```

### Translation Hooks

```typescript
// Enhanced translation hook with tenant context
export const useTranslation = (namespace?: string) => {
  const { t, i18n } = useTranslationBase(namespace);
  const { organization, property } = useTenant();
  const [isLoading, setIsLoading] = useState(false);

  // Enhanced translation function with tenant context
  const translate = useCallback(
    (key: string, options?: any) => {
      // Add tenant context to translation request
      const tenantOptions = {
        ...options,
        organizationId: organization?.id,
        propertyId: property?.id,
      };

      return t(key, tenantOptions);
    },
    [t, organization?.id, property?.id]
  );

  // Change language with tenant context
  const changeLanguage = useCallback(
    async (language: string) => {
      setIsLoading(true);
      try {
        // Update user preferences
        await userService.updateLanguagePreference(language);
        
        // Change i18n language
        await i18n.changeLanguage(language);
        
        // Reload translations with tenant context
        await i18n.reloadResources(language);
      } finally {
        setIsLoading(false);
      }
    },
    [i18n]
  );

  return {
    t: translate,
    i18n,
    changeLanguage,
    isLoading,
    currentLanguage: i18n.language,
  };
};

// Language selector hook
export const useLanguageSelector = () => {
  const { currentLanguage, changeLanguage, isLoading } = useTranslation();
  const [availableLanguages, setAvailableLanguages] = useState<Language[]>([]);

  useEffect(() => {
    // Load available languages for current tenant
    const loadLanguages = async () => {
      const languages = await translationService.getAvailableLanguages();
      setAvailableLanguages(languages);
    };

    loadLanguages();
  }, []);

  return {
    currentLanguage,
    availableLanguages,
    changeLanguage,
    isLoading,
  };
};
```

### Translation Components

```typescript
// Language selector component
export const LanguageSelector: React.FC = () => {
  const { currentLanguage, availableLanguages, changeLanguage, isLoading } = useLanguageSelector();

  return (
    <Select value={currentLanguage} onValueChange={changeLanguage} disabled={isLoading}>
      <SelectTrigger className="w-40">
        <div className="flex items-center gap-2">
          <Globe className="w-4 h-4" />
          <SelectValue />
        </div>
      </SelectTrigger>
      <SelectContent>
        {availableLanguages.map((language) => (
          <SelectItem key={language.code} value={language.code}>
            <div className="flex items-center gap-2">
              <span>{language.nativeName}</span>
              <span className="text-xs text-muted-foreground">({language.name})</span>
            </div>
          </SelectItem>
        ))}
      </SelectContent>
    </Select>
  );
};

// Translation editor component
export const TranslationEditor: React.FC<{
  namespace: string;
}> = ({ namespace }) => {
  const { t } = useTranslation(namespace);
  const [translations, setTranslations] = useState<Translation[]>([]);
  const [selectedLanguage, setSelectedLanguage] = useState('en');
  const [isEditing, setIsEditing] = useState<string | null>(null);

  const handleUpdateTranslation = async (id: string, value: string) => {
    try {
      await translationService.updateTranslation(id, { value });
      // Refresh translations
      await loadTranslations();
      setIsEditing(null);
    } catch (error) {
      console.error('Failed to update translation:', error);
    }
  };

  return (
    <div className="translation-editor">
      <div className="translation-editor-header">
        <LanguageSelector />
        <Button onClick={() => generateMissingTranslations()}>
          Generate Missing Translations
        </Button>
      </div>

      <div className="translation-list">
        {translations.map((translation) => (
          <div key={translation.id} className="translation-item">
            <div className="translation-key">{translation.key}</div>
            <div className="translation-value">
              {isEditing === translation.id ? (
                <TranslationEditForm
                  value={translation.value}
                  onSave={(value) => handleUpdateTranslation(translation.id, value)}
                  onCancel={() => setIsEditing(null)}
                />
              ) : (
                <div onClick={() => setIsEditing(translation.id)}>
                  {translation.value}
                </div>
              )}
            </div>
            <div className="translation-status">
              <Badge variant={getStatusVariant(translation.status)}>
                {translation.status}
              </Badge>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
};
```

### Locale Formatting

```typescript
// Locale formatting utilities
export class LocaleFormatter {
  constructor(private readonly locale: string) {}

  formatDate(date: Date, options?: Intl.DateTimeFormatOptions): string {
    return new Intl.DateTimeFormat(this.locale, {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      ...options,
    }).format(date);
  }

  formatTime(date: Date, format: '12h' | '24h' = '12h'): string {
    return new Intl.DateTimeFormat(this.locale, {
      hour: 'numeric',
      minute: '2-digit',
      hour12: format === '12h',
    }).format(date);
  }

  formatCurrency(amount: number, currency: string): string {
    return new Intl.NumberFormat(this.locale, {
      style: 'currency',
      currency,
    }).format(amount);
  }

  formatNumber(number: number, options?: Intl.NumberFormatOptions): string {
    return new Intl.NumberFormat(this.locale, options).format(number);
  }

  formatPercent(value: number): string {
    return new Intl.NumberFormat(this.locale, {
      style: 'percent',
      minimumFractionDigits: 1,
      maximumFractionDigits: 1,
    }).format(value);
  }

  formatRelativeTime(date: Date): string {
    const rtf = new Intl.RelativeTimeFormat(this.locale, { numeric: 'auto' });
    const diffInDays = Math.floor((date.getTime() - Date.now()) / (1000 * 60 * 60 * 24));
    
    if (Math.abs(diffInDays) < 1) {
      const diffInHours = Math.floor((date.getTime() - Date.now()) / (1000 * 60 * 60));
      return rtf.format(diffInHours, 'hour');
    }
    
    return rtf.format(diffInDays, 'day');
  }
}

// React hook for locale formatting
export const useLocaleFormatter = () => {
  const { i18n } = useTranslation();
  const { property } = useTenant();
  
  const locale = property?.locale || i18n.language;
  const currency = property?.currency || 'USD';
  
  const formatter = useMemo(() => new LocaleFormatter(locale), [locale]);
  
  return {
    formatDate: formatter.formatDate.bind(formatter),
    formatTime: formatter.formatTime.bind(formatter),
    formatCurrency: (amount: number) => formatter.formatCurrency(amount, currency),
    formatNumber: formatter.formatNumber.bind(formatter),
    formatPercent: formatter.formatPercent.bind(formatter),
    formatRelativeTime: formatter.formatRelativeTime.bind(formatter),
  };
};
```

## Translation Management

### Translation Workflow

1. **Development Phase**:
   - Developers add translation keys using `t('key')`
   - Keys are automatically extracted and added to translation files
   - Base English translations are created

2. **Translation Phase**:
   - AI generates initial translations for supported languages
   - Human translators review and improve AI translations
   - Quality scores are assigned to translations

3. **Review Phase**:
   - Native speakers verify translations
   - Translations are marked as 'verified'
   - Feedback is incorporated

4. **Deployment Phase**:
   - Verified translations are deployed
   - Fallback mechanisms ensure no missing translations

### Translation Key Conventions

```typescript
// Naming convention for translation keys
const translationKeys = {
  // Format: {module}.{section}.{specific}
  'common.actions.save': 'Save',
  'common.actions.cancel': 'Cancel',
  'common.actions.delete': 'Delete',
  
  'hr.employees.title': 'Employees',
  'hr.employees.create': 'Create Employee',
  'hr.employees.edit': 'Edit Employee',
  
  'front_desk.checkin.title': 'Check In',
  'front_desk.checkin.guest_name': 'Guest Name',
  'front_desk.checkin.room_number': 'Room Number',
  
  // Variables in translations
  'common.welcome_message': 'Welcome, {{name}}!',
  'hr.payslip.summary': 'Payslip for {{month}} {{year}}',
  
  // Pluralization
  'common.items_count': {
    '0': 'No items',
    '1': 'One item',
    'other': '{{count}} items',
  },
};
```

This comprehensive internationalization system ensures Hotel Operations Hub can serve a global market while maintaining high-quality, contextually appropriate translations for the hospitality industry.