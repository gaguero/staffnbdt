# Permission System Examples\n\nThis document provides examples of how to use the new flexible permission system in the Hotel Operations Hub.\n\n## Basic Permission Usage\n\n### String Format\n```typescript\n@Controller('users')\nexport class UsersController {\n  \n  @Get()\n  @RequirePermission('users.read.property') // Users can read all users in their property\n  async findAll() { ... }\n  \n  @Post()\n  @RequirePermission('users.create.department') // Users can create users in their department\n  async create() { ... }\n  \n  @Delete(':id')\n  @RequirePermission('users.delete.platform') // Only platform admins can delete\n  async remove() { ... }\n}\n```\n\n### Object Format\n```typescript\n@Controller('users')\nexport class UsersController {\n  \n  @Patch(':id')\n  @RequirePermission({\n    resource: 'users',\n    action: 'update', \n    scope: 'department',\n    conditions: { sameDepartment: true } // Additional validation\n  })\n  async update() { ... }\n}\n```\n\n### Multiple Permissions (OR Logic)\n```typescript\n@Controller('users')\nexport class UsersController {\n  \n  @Get(':id')\n  @RequirePermission([\n    'users.read.own', // Can read own profile\n    'users.read.department' // OR can read department users\n  ])\n  async findOne() { ... }\n}\n```\n\n## Automatic Scope Filtering\n\n```typescript\n@Controller('users')\nexport class UsersController {\n  \n  @Get()\n  @RequirePermission('users.read.property')\n  @PermissionScope('property') // Automatically filter by user's propertyId\n  async findAll(@Request() req) {\n    // req.permissionFilters will contain { propertyId: user.propertyId }\n    const filters = getPermissionFilters(req);\n    return this.usersService.findAll(filters);\n  }\n}\n```\n\n## Conditional Permissions\n\n### Owner or Permission\n```typescript\n@Controller('profiles')\nexport class ProfileController {\n  \n  @Get(':id')\n  @OwnerOrPermission({\n    ownerField: 'userId',\n    fallbackPermission: 'profile.read.department',\n    errorMessage: 'You can only view your own profile or have department read permissions'\n  })\n  async getProfile() { ... }\n}\n```\n\n### Time-Based Permissions\n```typescript\n@Controller('vacation')\nexport class VacationController {\n  \n  @Post()\n  @TimeBasedPermission({\n    permission: 'vacation.create.own',\n    timeCondition: (ctx) => {\n      const hour = new Date().getHours();\n      return hour >= 9 && hour <= 17; // Working hours only\n    },\n    errorMessage: 'Vacation requests can only be submitted during working hours (9 AM - 5 PM)'\n  })\n  async create() { ... }\n}\n```\n\n### State-Based Permissions\n```typescript\n@Controller('vacation')\nexport class VacationController {\n  \n  @Patch(':id/approve')\n  @StateBasedPermission({\n    permission: 'vacation.approve.department',\n    stateCondition: async (ctx) => {\n      const vacation = await this.vacationService.findOne(ctx.params.id);\n      return vacation.status === 'PENDING';\n    },\n    errorMessage: 'You can only approve vacation requests that are pending'\n  })\n  async approve() { ... }\n}\n```\n\n### Custom Conditional Logic\n```typescript\n@Controller('payroll')\nexport class PayrollController {\n  \n  @Get(':id/payslip')\n  @ConditionalPermission({\n    permission: 'payroll.read.department',\n    condition: async (ctx) => {\n      // Complex business logic\n      if (ctx.user.role === 'PLATFORM_ADMIN') return true;\n      \n      const payslip = await this.payrollService.findPayslip(ctx.params.id);\n      const isOwner = payslip.userId === ctx.user.id;\n      const sameDepartment = payslip.user.departmentId === ctx.user.departmentId;\n      const isManager = ctx.user.role === 'DEPARTMENT_ADMIN' && sameDepartment;\n      \n      return isOwner || isManager;\n    },\n    description: 'Can view own payslips or manage department payslips',\n    errorMessage: 'You can only view your own payslips or those in your managed department'\n  })\n  async getPayslip() { ... }\n}\n```\n\n## Migration from @Roles to @RequirePermission\n\n### Before (Old @Roles System)\n```typescript\n@Controller('users')\nexport class UsersController {\n  \n  @Get()\n  @Roles(Role.PLATFORM_ADMIN, Role.DEPARTMENT_ADMIN)\n  async findAll() { ... }\n  \n  @Post()\n  @Roles(Role.PLATFORM_ADMIN)\n  async create() { ... }\n}\n```\n\n### After (New @RequirePermission System)\n```typescript\n@Controller('users')\nexport class UsersController {\n  \n  @Get()\n  @RequirePermission([\n    'users.read.platform', // Platform admin access\n    'users.read.department' // Department admin access\n  ])\n  async findAll() { ... }\n  \n  @Post()\n  @RequirePermission('users.create.platform') // Only platform admins\n  async create() { ... }\n}\n```\n\n## Permission Constants\n\nUse predefined permission constants for consistency:\n\n```typescript\nimport { PERMISSIONS } from '../shared/decorators/require-permission.decorator';\n\n@Controller('users')\nexport class UsersController {\n  \n  @Get()\n  @RequirePermission(PERMISSIONS.USERS.READ_DEPARTMENT)\n  async findAll() { ... }\n  \n  @Post()\n  @RequirePermission(PERMISSIONS.USERS.CREATE_DEPARTMENT)\n  async create() { ... }\n  \n  @Patch(':id/role')\n  @RequirePermission(PERMISSIONS.USERS.CHANGE_ROLE)\n  async changeRole() { ... }\n}\n```\n\n## Service Integration\n\nIntegrate with services for automatic filtering:\n\n```typescript\n@Injectable()\nexport class UsersService {\n  \n  async findAll(request: any, filterDto: UserFilterDto) {\n    // Apply permission-based filters automatically\n    const where = applyPermissionFilters({\n      ...filterDto,\n      deletedAt: null,\n    }, request);\n    \n    return this.prisma.user.findMany({ where });\n  }\n}\n```\n\n## Error Handling\n\nThe permission system provides clear error messages:\n\n```typescript\n// Permission denied responses:\n{\n  \"statusCode\": 403,\n  \"message\": \"Access denied: Role STAFF does not have permission users.delete.platform\",\n  \"error\": \"Forbidden\"\n}\n\n{\n  \"statusCode\": 403,\n  \"message\": \"Access denied: You can only view your own profile or have department read permissions\",\n  \"error\": \"Forbidden\"\n}\n```\n\n## Backwards Compatibility\n\nDuring migration, both systems work together:\n\n1. Set `USE_PERMISSION_SYSTEM=true` in environment variables\n2. Endpoints with `@RequirePermission` use the new system\n3. Endpoints with only `@Roles` fall back to the old system\n4. Endpoints with both decorators prioritize `@RequirePermission`\n\n## Best Practices\n\n1. **Use specific scopes**: Prefer `department` over `platform` when possible\n2. **Leverage constants**: Use `PERMISSIONS.*` constants instead of string literals\n3. **Combine with scope filtering**: Use `@PermissionScope` for automatic filtering\n4. **Test thoroughly**: Permission changes affect security, test all scenarios\n5. **Document custom conditions**: Provide clear descriptions for complex conditions\n6. **Follow the principle of least privilege**: Grant minimum necessary permissions\n\n## Performance Considerations\n\n- Permission evaluation is cached per request\n- Scope filters are applied at the database level\n- Conditional permissions with async operations may impact performance\n- Consider using database views for complex permission queries\n\n## Debugging\n\nEnable debug logging to troubleshoot permission issues:\n\n```bash\n# Enable permission debug logs\nLOG_LEVEL=debug\n```\n\nLogs will show:\n- Permission evaluation results\n- Applied scope filters\n- Condition evaluation outcomes\n- Role-to-permission mappings (during migration)